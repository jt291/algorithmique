% td-info-S1-annexes

%-----------------------------------------------------------------------------
\section{Codes ASCII}\label{ascii}
%-----------------------------------------------------------------------------
L'ordinateur stocke toutes les données sous forme numérique
(ensemble de bits). En particulier, les caractères ont un équivalent numérique : 
le code ASCII ({\em American Standard Code for Information Interchange}). 
Le code ASCII de base code les caractères sur 7 bits (128 caractères, de 0 à 127).
\begin{itemize}
\item Les codes 0 à 31 sont des caractères de contrôle (figure \ref{fig:ascii}).
\item Les codes 32 à 47, de 58 à 64, de 91 à 96 et de 123 à 126 
	sont des symboles de ponctuation.
{\footnotesize\tt$$\begin{tabular}{|cccccccccccccccc|}
\hline
32 & 33 & 34 & 35 & 36 & 37 & 38 & 39 & 40 & 41 & 42 & 43 & 44 & 45 & 46 & 47 \\
   & !  & " 	& \# & \$ & \% & \& & '  & (  &	)  & * 	& +  & ,  & -  & .  & / \\
\hline
\end{tabular}$$}
{\footnotesize\tt$$\begin{tabular}{|ccccccc|}
\hline
58 & 59 & 60 & 61 & 62 & 63 & 64 \\
:  & ;  & <  & =  & >  & ?  & @	\\
\hline
\end{tabular}\hspace*{2mm}
\begin{tabular}{|cccccc|}
\hline
91 & 92 & 93 & 94 & 95 & 96 \\
\char`[ & \char`\\ & \char`] & \char`^ & \_ & ` \\
\hline
\end{tabular}\hspace*{2mm}
\begin{tabular}{|cccc|}
\hline
123 & 124 & 125 & 126 \\
 \{  & |  & \}  & \char`~ \\
\hline
\end{tabular}$$}
\item Les codes de 48 à 57 représentent les 10 chiffres de 0 à 9.
\item Les codes 65 à 90 représentent les majuscules de {\tt A} à {\tt Z},
\item Les codes 97 à 122 représentent les minuscules de {\tt a} à {\tt z}
	(il suffit d'ajouter 32 au code ASCII d'une majuscule
	pour obtenir la minuscule correspondante).
\item Les caractères accentués ({\tt é}, {\tt è} \ldots) font l'objet d'un code ASCII étendu
	de 128 à 255.
\end{itemize}
\begin{fig}[Codes ASCII des caractères de contrôle]\label{fig:ascii}
\scriptsize
$$\begin{tabular}[t]{lll}
code & caractère & signification \\
\hline
0 & NUL & \em Null\\
1 & SOH & \em Start of heading\\
2 & STX & \em Start of text\\
3 & ETX & \em End of text\\
4 & EOT & \em End of transmission\\
5 & ENQ & \em Enquiry\\
6 & ACK & \em Acknowledge\\
7 & BEL & \em Bell\\
8 & BS  & \em Backspace\\
9 & TAB & \em Horizontal tabulation\\
10 & LF & \em Line Feed\\
11& VT  & \em Vertical tabulation\\
12& FF  & \em Form feed\\
13& CR  & \em Carriage return\\
14& SO  & \em Shift out\\
15& SI  & \em Shift in
\end{tabular}
\hspace*{1cm}
\begin{tabular}[t]{lll}
code & caractère & signification \\
\hline
16& DLE & \em Data link escape\\
17& DC1 & \em Device control 1\\
18& DC2 & \em Device control 2\\
19& DC3 & \em Device control 3\\
20& DC4 & \em Device control 4\\
21& NAK & \em Negative acknowledgement\\
22& SYN & \em Synchronous idle\\
23& ETB & \em End of transmission block\\
24& CAN & \em Cancel\\    
25& EM  & \em End of medium\\
26& SUB & \em Substitute\\
27& ESC & \em Escape\\
28& FS  & \em File separator\\
29& GS  & \em Group separator\\
30& RS  & \em Record separator\\
31& US  & \em Unit separator
\end{tabular}$$
\end{fig}

%-------------------------------------------------------------------------
\section{Instructions {\sc Python}}\label{python}
%-------------------------------------------------------------------------
Les principales instructions {\sc Python} sont listées dans les tableaux
ci-dessous.

\begin{longtable}{|p{5.5cm}|p{9.5cm}|}
\multicolumn{2}{l}{\bf Miscellaneous statements}\\
\hline
\bf Statement & \bf Result \\
\hline
\tt pass & Null statement \\
\hline
\tt del name[, name]* &	Unbind {\tt name}(s) from object \\
\hline
\tt print([s1 [, s2 ]*) & Writes to {\tt sys.stdout}, or to {\tt file\-object} if supplied. 
                                             Puts spaces between arguments {\tt si}. Puts newline at end unless arguments end with {\tt end=} (ie: {\tt end=' '}). 
					     {\tt print} is not required when running interactively, simply typing an expression will print its value, 
					     unless the value is {\tt None}.\\
\hline
\tt input([prompt]) & 	Prints {\tt prompt} if given. Reads input and evaluates it. \\
\hline
\multicolumn{2}{l}{}\\
\multicolumn{2}{l}{\bf Assignment operators}\\
\hline
\bf Operator & \bf Result \\
\hline
\tt a = b 	& Basic assignment - assign object {\tt b} to label {\tt a}\\
\hline
\tt a += b 	& \tt a = a + b 	\\
\tt a -= b 	& \tt a = a - b 	\\
\tt a *= b 	& \tt a = a * b 	\\
\tt a /= b 	& \tt a = a / b 	\\
\tt a //= b 	& \tt a = a // b	\\
\tt a \%= b 	& \tt to a = a \% b	\\
\tt a **= b 	& \tt to a = a ** b	\\
\tt a \&= b 	& \tt a = a \& b	\\
\tt a |= b 	& \tt a = a | b 	\\
\tt a \char`^= b& \tt a = a \char`^\ b 	\\
\tt a >>= b 	& \tt a = a >> b	\\
\tt a <<= b 	& \tt a = a << b	\\
\hline
\multicolumn{2}{l}{}\\
\multicolumn{2}{l}{\bf Control flow statements}\\
\hline
\bf Statement & \bf Result \\
\hline
\tt if condition:\newline
\mbox{}\ \ suite\newline
[elif condition: suite]*\newline
[else:\newline
\mbox{}\ \ suite] & Usual {\tt if/else if/else} statement.\\
\hline
\tt while condition:\newline
\mbox{}\ \ suite\newline
[else:\newline
\mbox{}\ \ suite] & Usual {\tt while} statement. The {\tt else suite} is executed after 
           loop exits, unless the loop is exited with {\tt break}.\\
\hline
\tt for element in sequence:\newline
\mbox{}\ \ suite\newline
[else:\newline
\mbox{}\ \ suite] & Iterates over {\tt sequence}, assigning each element to {\tt element}. 
           Use built-in {\tt range} function to iterate a number of times. 
	   The {\tt else suite} is executed at end unless loop exited with {\tt break}.\\
\hline
\tt break & Immediately exits for or while loop.\\
\tt continue & Immediately does next iteration of for or while loop.\\
\hline
\tt return [result] & Exits from function (or method) and returns {\tt result} 
                     (use a tuple to return more than one value).\\
\hline
\end{longtable}

\noindent{\bf Name space statements}\\
Imported module files must be located in a directory listed in the {\tt path} ({\tt sys.path}).
 
Packages: a package is a name space which maps to a directory including 
module(s) and the special initialization module {\tt \_\_init\_\_.py} (possibly empty).

Packages/directories can be nested. You address a module's symbol via \\
{\tt [package.[package...].module.symbol} .

$$\begin{tabular}{|p{5.5cm}|p{9.5cm}|}
\hline
\bf Statement & \bf Result \\
\hline
{\tt import module1 [as name1] [, module2]*} 	& Imports modules. 
	Members of module must be referred to by qualifying with {\tt [package.]module} name, e.g.:\newline
	{\tt \mbox{}\ \ import sys; print(sys.argv)\newline
	\mbox{}\ \ import package1.subpackage.module\newline
	\mbox{}\ \ package1.subpackage.module.foo()}\newline
	{\tt module1} renamed as {\tt name1}, if supplied.\\
\hline
{\tt \tt from module import name1 [as othername1][, name2]*} 	& Imports {\tt name}s from module {\tt module} 
	in current namespace, e.g. :\newline
{\tt 
\mbox{}\ \ from sys import argv; print(argv)\newline
\mbox{}\ \ from package1 import module; \newline\mbox{}\ \ module.foo()\newline
\mbox{}\ \ from package1.module import foo; \newline\mbox{}\ \ foo()}\newline
{\tt name1} renamed as {\tt othername1}, if supplied.\\
\hline
{\tt from module import * } 	 & Imports all names in {\tt module}, except those starting with {\tt \_}. \\
\hline
\end{tabular}$$

%-------------------------------------------------------------------------
%\newpage
\section{Fonctions en {\sc Python}}\label{python:def}
%-------------------------------------------------------------------------
Le principe de la définition d'une fonction en {\sc Python} est présentée
ci-dessous.

{\footnotesize
$$\begin{tabular}{|p{5cm}|p{8cm}|}
\hline
\tt def funcName([paramList]):\newline \mbox{}\ \ \ \ block & 
	Creates a function object and binds it to name {\tt funcName}.\newline
	{\tt paramList ::= [param [, param]*]}\newline
	{\tt param ::= value | id=value | *id | **id}\\
\hline
\end{tabular}$$
}

\noindent\begin{itemize}
\item Arguments are passed by value, so only arguments representing a mutable object can be modified (are inout parameters).
\item Use {\tt return} to return {\tt None} from the function, or {\tt return value} to return a value. 
	Use a tuple to return more than one value, e.g. {\tt return 1,2,3}.
\item Keyword arguments {\tt arg=value} specify a default value (evaluated at function definition time). 
	They can only appear last in the param list, e.g. {\tt foo(x, y=1, s='')}.
\item Pseudo-arg {\tt *args} captures a tuple of all remaining non-keyword args passed to the function, 
	e.g. if {\tt def foo(x, *args): ...} is called {\tt foo(1, 2, 3)}, then {\tt args} will contain {\tt (2,3)}.
\item Pseudo-arg {\tt **kwargs} captures a dictionary of all extra keyword arguments, 
	e.g. if {\tt def foo(x, **kwargs): ...} is called {\tt foo(1, y=2, z=3)}, then {\tt kwargs} will contain {\tt \{'y':2, 'z':3\}}. 
	if {\tt def foo(x, *args, **kwargs): ...} is called {\tt foo(1, 2, 3, y=4, z=5)}, then {\tt args} will contain {\tt (2, 3)}, 
	and {\tt kwargs} will contain {\tt \{'y':4, 'z':5\}}.
\item {\tt args} and {\tt kwargs} are conventional names, but other names may be used as well.
\item {\tt *args} and {\tt **kwargs} can be "forwarded" (individually or together) to another function, e.g.
      {\tt def f1(x, *args, **kwargs): f2(*args, **kwargs)}.
\end{itemize}

%-------------------------------------------------------------------------
%\newpage
\section{Fonctions {\sc Python} prédéfinies}\label{python:fonctions}
%-------------------------------------------------------------------------
Les principales fonctions prédéfinies en {\sc Python} sont listées dans les tableaux
ci-dessous.

{\footnotesize
\begin{longtable}{|l|p{9cm}|}
\hline
\bf Function & \bf Result \\
\hline
\hline
\tt abs(x)		& Returns the absolute value of the number {\tt x}.\\
\hline
\tt all(iterable) 	& Returns {\tt True} if {\tt bool(x)} is {\tt True} for all values {\tt x} in the {\tt iterable}.\\
\hline
\tt any(iterable) 	& Returns {\tt True} if {\tt bool(x)} is {\tt True} for any values {\tt x} in the {\tt iterable}.\\
\hline
\tt bool([x]) 		& Converts a value to a Boolean, using the standard truth testing procedure. If {\tt x} is false or omitted, 
			  returns {\tt False}; otherwise returns {\tt True}.\\ 
\hline
\tt chr(i) 		& Returns one-character string whose ASCII code is integer {\tt i}.\\
\hline
\tt cmp(x,y) 		& Returns negative, 0, positive if {\tt x <}, {\tt ==}, {\tt >} to {\tt y} respectively.\\
\hline
\tt complex(real[, image]) 	& Creates a complex object (can also be done using {\tt J} or {\tt j} suffix, e.g. {\tt 1+3J}).\\
\hline
\tt dict([mapping-or-sequence]) & Returns a new dictionary initialized from the optional argument (or an empty dictionary if no argument). 
				  Argument may be a sequence (or anything iterable) of pairs (key,value).\\
\hline
\tt dir([object]) 		& Without args, returns the list of names in the current local symbol table. 
			  	  With a module, class or class instance {\tt object} as arg, returns the list of names in its attr. dictionary.\\
\hline
\tt divmod(a,b) 	& Returns tuple ({\tt a//b}, {\tt a\%b}).\\
\hline
\tt enumerate(iterable) & Iterator returning pairs (index, value) of {\tt iterable}, e.g. {\tt List(enumerate('Py'))} 
			  $\rightarrow$ {\tt [(0, 'P'), (1, 'y')]}.\\
\hline
\tt eval(s[, globals[, locals]])& Evaluates string {\tt s}, representing a single python expression, in (optional) {\tt globals}, 
				  {\tt locals} contexts.\newline
				  Example: {\tt x = 1; assert eval('x + 1') == 2}\\
\hline
\tt execfile(file[, globals[,locals]])	& Executes a {\tt file} without creating a new module, unlike import.\\
\hline
\tt filter(function,sequence) 	& Constructs a list from those elements of {\tt sequence} for which {\tt function} returns true. 
				  {\tt function} takes one parameter.\\
\hline
\tt float(x) 		& Converts a number or a string to floating point.\\
\hline
\tt globals() 		& Returns a dictionary containing the current global variables.\\
\hline
\tt help([object]) 	& Invokes the built-in help system. No argument $\rightarrow$ interactive help; if {\tt object} is a string 
			  (name of a module, function, class, method, keyword, or documentation topic), a help page is printed on the console; 
			  otherwise a help page on {\tt object} is generated.\\
\hline
\tt hex(x) 		& Converts a number {\tt x} to a hexadecimal string.\\
\hline
\tt id(object) 		& Returns a unique integer identifier for {\tt object}.\\ 
\hline
\tt input([prompt]) 	& Prints {\tt prompt} if given. Reads input and evaluates it.\\
\hline
\tt int(x[, base]) 	& Converts a number or a string to a plain integer. Optional {\tt base} parameter specifies base from which 
			  to convert string values.\\
\hline
\tt len(obj) 		& Returns the length (the number of items) of an object (sequence, dictionary).\\
\hline
\tt list([seq]) 	& Creates an empty list or a list with same elements as {\tt seq}. 
			  {\tt seq} may be a sequence, a container that supports iteration, or an iterator object. 
			  If {\tt seq} is already a list, returns a copy of it.\\
\hline
\tt locals() 		& Returns a dictionary containing current local variables.\\
\hline
\tt map(function, sequence)	& Returns a list of the results of applying {\tt function} to each item from {\tt sequence}(s).\\
\hline
\tt oct(x) 		& Converts a number to an octal string.\\
\hline
\tt open(filename[,mode='r',[bufsize]])	& Returns a new file object. {\tt filename} is the file name to be opened.
						  {\tt mode} indicates how the file is to be opened ({\tt 'r', 'w', 'a', '+', 'b', 'U'}).
						  {\tt bufsize} is 0 for unbuffered, 1 for line buffered, 
						  negative or omitted for system default, {\tt >1} for a buffer of (about) the given size.\\
\hline
\tt ord(c) 		& Returns integer ASCII value of {\tt c} (a string of len 1).\\
\hline
\tt range([start,] end [, step])	& Returns list of ints from {\tt >= start} and {\tt < end}.
					  With 1 arg, list from {\tt 0..arg-1}. With 2 args, list from {\tt start..end-1}.
					  With 3 args, list from {\tt start} up to {\tt end} by {\tt step}.\\
\hline
\tt raw\_input([prompt])& Prints {\tt prompt} if given, then reads string from std input (no trailing {\tt \char`\n}).\\
\hline
\tt reload(module) 	& Re-parses and re-initializes an already imported {\tt module}.\\
\hline
\tt repr(object) 	& Returns a string containing a printable and if possible evaluable representation of an {\tt object}. 
			  $\equiv$ {\tt `object`} (using backquotes).\\
\hline
\tt round(x, n=0) 	& Returns the floating point value {\tt x} rounded to {\tt n} digits after the decimal point.\\
\hline
\tt str(object) 	& Returns a string containing a nicely printable representation of an {\tt object}.\\
\hline
\tt sum(iterable[, start=0])	& Returns the sum of a sequence of numbers (not strings), plus the value of parameter. 
				  Returns {\tt start} when the sequence is empty.\\
\hline
\tt tuple([seq]) 	& Creates an empty tuple or a tuple with same elements as {\tt seq}.\\
\hline
\tt type(obj) 		& Returns a type object representing the type of {\tt obj}.\\
\hline
\tt xrange(start [, end [, step]])	& Like {\tt range()}, but doesn't actually store entire list all at once. 
					  Good to use in {\tt for} loops when there is a big range and little memory.\\
\hline
\end{longtable}
}

%-------------------------------------------------------------------------
%\newpage
\section{Instructions {\sc Logo}}\label{logo}
%-------------------------------------------------------------------------
{\footnotesize
\begin{description}
\item[\tt degrees()] fixe l'unité d'angle en degrés
\item[\tt radians()] fixe l'unité d'angle en radians
\item[\tt reset()] efface l'écran et réinitialise les variables
\item[\tt clear()] efface l'écran
\item[\tt up()] lève le crayon 
\item[\tt down()] abaisse le crayon 
\item[\tt forward(d)] avance d'une distance $d$
\item[\tt backward(d)] recule d'une distance $d$
\item[\tt left(a)] tourne sur la gauche d'un angle $a$
\item[\tt right(a)] tourne sur la droite d'un angle $a$
\item[\tt goto(x,y)] déplace le crayon à la position $(x,y)$
\item[\tt towards(x,y)] oriente vers le point de coordonnées $(x,y)$
\item[\tt setheading(a)] oriente d'un angle $a$ par rapport à l'axe des $x$
\item[\tt position()] donne la position $(x,y)$ du crayon
\item[\tt heading()] donne l'orientation $a$ du déplacement 
\item[\tt circle(r)] trace un cercle de rayon $r$
\item[\tt circle(r,a)] trace un arc de cercle de rayon $r$ et d'angle au sommet $a$.
\end{description}
}

\noindent Pour utiliser ces fonctions, il faut les importer depuis le module {\tt turtle} :\\
{\tt >>> from turtle import *} .

%-------------------------------------------------------------------------
\section{Les séquences en {\sc Python}}\label{python:listes}
%-------------------------------------------------------------------------
Les principales opérations sur les séquences en {\sc Python} ({\tt list}, 
{\tt tuple}, {\tt str}) sont listées dans les tableaux ci-dessous.


\begin{longtable}{|p{5cm}|p{10cm}|}
\hline
\bf Operation on sequences \label{tab:sequences} &\\
\bf ({\tt list}, {\tt tuple}, {\tt str}) &	\bf Result \\
\hline
\hline
\tt x in s 		& {\tt True} if an item of {\tt s} is equal to {\tt x}, else {\tt False} \\	
\tt x not in s 		& {\tt False} if an item of {\tt s} is equal to {\tt x}, else {\tt True} \\	
\hline
\tt s1 + s2 		& the concatenation of {\tt s1} and {\tt s2} \\	 
\tt s * n, n*s 		& {\tt n} copies of {\tt s} concatenated \\	
\hline
\tt s[i] 		& {\tt i}'th item of {\tt s}, origin {\tt 0} \\	
\tt s[i:j[:step]]	& Slice of {\tt s} from {\tt i} (included) to {\tt j}(excluded). 
		  	  Optional {\tt step} value, possibly negative (default: {\tt 1}) \\ 	
\hline
\tt len(s) 		& Length of {\tt s} \\ 
\tt min(s) 		& Smallest item of {\tt s} \\
\tt max(s) 		& Largest item of {\tt s} \\
\hline
\multicolumn{2}{l}{}\\
\hline
\bf Operation on {\tt list}	\label{tab:listes} &	\bf Result \\
\hline
\hline
\tt s[i] = x 			& item {\tt i} of {\tt s} is replaced by {\tt x} 	\\
\tt s[i:j [:step]] = t 		& slice of {\tt s} from {\tt i} to {\tt j} is replaced by {\tt t} \\	 
\tt del s[i:j[:step]] 		& same as {\tt s[i:j] = []} \\	 
\hline
\tt s.count(x) 			& returns number of {\tt i}'s for which {\tt s[i] == x} \\	 
\tt s.index(x[,start[,stop]]) 	& returns smallest {\tt i} such that {\tt s[i] == x}. 
				  {\tt start} and {\tt stop} limit search to only part 
				  of the list \\ 	
\hline
\tt s.append(x) 		& same as {\tt s[len(s) : len(s)] = [x]} \\	 
\tt s.extend(x) 		& same as {\tt s[len(s):len(s)]= x} \\	
\tt s.insert(i, x) 		& same as {\tt s[i:i] = [x] if i>= 0}. {\tt i == -1} inserts before the last element\\ 	 
\tt s.remove(x) 		& same as {\tt del s[s.index(x)]} \\
\tt s.pop([i]) 			& same as {\tt x = s[i]; del s[i]; return x} 	\\
\hline
\tt s.reverse() 		& reverses the items of {\tt s} in place \\	
\tt s.sort([cmp ]) 		& sorts the items of {\tt s} in place \\   
\hline
\multicolumn{2}{l}{}\\
\hline
\bf Operation on {\tt str}	\label{tab:chaines} &	\bf Result \\
\hline
\hline
\tt s.capitalize() 			& Returns a copy of {\tt s} with its first character capitalized, and the rest of the characters lowercased\\ 	 
\tt s.center(width[,\newline
\mbox{}\hfill fillChar=' ']) 		& Returns a copy of {\tt s} centered in a string of length {\tt width}, surrounded by the appropriate 
					  number of {\tt fillChar} characters\\ 	
\tt s.count(sub[,start[,\newline
\mbox{}\hfill end]]) 			& Returns the number of occurrences of substring {\tt sub} in string {\tt s}\\ 	
\tt s.decode([encoding[,\newline
\mbox{}\hfill errors]]) 		& Returns a unicode string representing the decoded version of str {\tt s}, 
					  using the given codec ({\tt encoding}). Useful when reading from a file 
					  or a I/O function that handles only str. Inverse of {\tt encode}\\	
\tt s.encode([encoding[,\newline
\mbox{}\hfill errors]]) 		& Returns a str representing an encoded version of {\tt s}. 
					  Mostly used to encode a unicode string to a str in order 
					  to print it or write it to a file (since these I/O functions
					  only accept str). Inverse of {\tt decode} \\	
\tt s.endswith(suffix[,\newline
\mbox{}\hfill start[,end]]) 		& Returns {\tt True} if {\tt s} ends with the specified {\tt suffix}, 
					  otherwise return {\tt False}.\\	
\tt s.expandtabs([tabsize]) 		& Returns a copy of {\tt s} where all tab characters are expanded using spaces\\ 	
\tt s.find(sub[,start[,\newline
\mbox{}\hfill end]]) 			& Returns the lowest index in {\tt s} where substring {\tt sub} is found. Returns {\tt -1} if {\tt sub} is not found\\ 	
\tt s.index(sub[,start[,\newline
\mbox{}\hfill end]]) 			& like {\tt find()}, but raises {\tt ValueError} when the substring {\tt sub} is not found\\	
\tt s.isalnum() 			& Returns {\tt True} if all characters in {\tt s} are alphanumeric, {\tt False} otherwise\\ 	
\tt s.isalpha() 			& Returns {\tt True} if all characters in {\tt s} are alphabetic, {\tt False} otherwise\\	
\tt s.isdigit() 			& Returns {\tt True} if all characters in {\tt s} are digit characters, {\tt False} otherwise\\ 	
\tt s.isspace() 			& Returns {\tt True} if all characters in {\tt s} are whitespace characters, {\tt False} otherwise\\ 	
\tt s.istitle() 				& Returns {\tt True} if string {\tt s} is a titlecased string, {\tt False} otherwise\\
\tt s.islower() 				& Returns {\tt True} if all characters in {\tt s} are lowercase,{\tt False} otherwise\\ 	
\tt s.isupper() 				& Returns {\tt True} if all characters in {\tt s} are uppercase, {\tt False} otherwise\\ 	
\tt separator.join(seq) 			& Returns a concatenation of the strings in the sequence {\tt seq}, separated by string {\tt separator}, 
                                 		  e.g.: {\tt ",".join(['A','B','C']) -> "A,B,C"}\\ 	
\tt s.ljust/rjust/center(\newline
\mbox{}\hfill width[,fillChar=' ']) 		& Returns {\tt s} {\tt l}eft/{\tt r}ight {\tt just}ified/{\tt center}ed in a string of length {\tt width}\\ 	
\tt s.lower() 					& Returns a copy of {\tt s} converted to lowercase\\ 	
\tt s.lstrip([chars]) 				& Returns a copy of {\tt s} with leading {\tt chars} (default: blank chars) removed\\ 	
\tt s.partition(separ) 				& Searches for the separator {\tt separ} in {\tt s}, and returns a tuple {\tt (head, sep, tail)} 
			 			  containing the part before it, the separator itself, and the part after it. 
			 			  If the separator is not found, returns {\tt s} and two empty strings\\ 	
\tt s.replace(old,new[,\newline
\mbox{}\hfill maxCount=-1]) 			& Returns a copy of {\tt s} with the first {\tt maxCount} 
						  ({\tt -1}: unlimited) occurrences of substring {\tt old} replaced by {\tt new}\\ 	
\tt s.rfind(sub[ ,start[,\newline
\mbox{}\hfill end]]) 				& Returns the highest index in {\tt s} where substring {\tt sub} is found. Returns {\tt -1} if {\tt sub} is not found\\ 	
\tt s.rindex(sub[,start[,\newline
\mbox{}\hfill end]]) 				& like {\tt rfind()}, but raises {\tt ValueError} when the substring {\tt sub} is not found\\ 	
\tt s.rpartition(separ) 			& Searches for the separator {\tt separ} in {\tt s}, starting at the {\tt end} of {\tt s}, and returns a tuple 
				 		  {\tt (tail, sep, head)} containing the part before it, the separator itself, and the part after it. 
				 		  If the separator is not found, returns two empty strings and {\tt s}\\ 	
\tt s.rstrip([chars]) 				& Returns a copy of {\tt s} with trailing {\tt chars} (default: blank chars) removed, 
			 			  e.g. {\tt aPath.rstrip('/')} will remove the trailing {\tt '/'} from {\tt aPath} if it exists\\	
\tt s.split([separator[,\newline
\mbox{}\hfill maxsplit]]) 			& Returns a list of the words in {\tt s}, using {\tt separator} as the delimiter string\\	
\tt s.rsplit([separator[,\newline
\mbox{}\hfill maxsplit]]) 			& Same as {\tt split}, but splits from the end of the string\\
\tt s.splitlines([keepends]) 			& Returns a list of the lines in {\tt s}, breaking at line boundaries\\	
\tt s.startswith(prefix[,\newline
\mbox{}\hfill start[,end]]) 			& Returns {\tt True} if {\tt s} starts with the specified {\tt prefix}, otherwise returns {\tt False}. 
                                                  Negative numbers may be used for {\tt start} and {\tt end}\\	
\tt s.strip([chars]) 				& Returns a copy of {\tt s} with leading and trailing {\tt chars} (default: blank chars) removed\\ 	
\tt s.swapcase() 				& Returns a copy of {\tt s} with uppercase characters converted to lowercase and vice versa\\
\tt s.title() 					& Returns a titlecased copy of {\tt s}, i.e. words start with uppercase characters, all remaining cased characters are lowercase\\ 	
\tt s.translate(table[,\newline
\mbox{}\hfill deletechars]) 			& Returns a copy of {\tt s} mapped through translation table {\tt table}\\ 	
\tt s.upper() 					& Returns a copy of {\tt s} converted to uppercase\\
\tt s.zfill(width) 				& Returns the numeric string left filled with zeros in a string of length {\tt width}\\ 	 
\hline
\end{longtable}


%-------------------------------------------------------------------------
\section{Les fichiers en {\sc Python}}\label{python:fichiers}
%-------------------------------------------------------------------------
Les principales opérations sur les fichiers en {\sc Python} (type {\tt file}) 
sont listées dans le tableau ci-dessous.

{\tt open(filename[,mode='r',[bufsize]])} returns a new file object. 
{\tt filename} is the file name to be opened.
{\tt mode} indicates how the file is to be opened ({\tt 'r', 'w', 'a', '+', 'b', 'U'}).
{\tt bufsize} is {\tt 0} for unbuffered, {\tt 1} for line buffered, 
negative or omitted for system default, {\tt >1} for a buffer of (about) the given size.

\label{tab:fichiers}
\begin{longtable}{|p{5cm}|p{10cm}|}
\hline
\bf Operation on {\tt file}	&	\bf Result \\
\hline
\hline
\tt f.close() 			& Close file {\tt f}\\
\tt f.fileno() 			& Get fileno ({\tt fd}) for file {\tt f}\\
\tt f.flush() 			& Flush file {\tt f}'s internal buffer\\
\tt f.isatty() 			& {\tt True} if file {\tt f} is connected to a tty-like dev, else {\tt False}\\
\hline
\tt f.next() 			& Returns the next input line of file {\tt f}, or raises {\tt StopIteration} when {\tt EOF} is hit\\
\tt f.read([size]) 		& Read at most {\tt size} bytes from file {\tt f} and return as a string object. If {\tt size} omitted, read to {\tt EOF}\\
\tt f.readline() 		& Read one entire line from file {\tt f}. The returned line has a trailing {\tt \char`\n}, except possibly at {\tt EOF}. Return {\tt ''} on {\tt EOF}\\
\tt f.readlines() 		& Read until {\tt EOF} with {\tt readline()} and return a list of lines read\\
\tt for line in f: ... 		& Iterate over the {\tt line}s of a file {\tt f} (using {\tt readline})\\
\hline
\tt f.seek(offset[, whence=0]) 	& Set file {\tt f}'s position\newline
				  {\tt whence == 0} then use absolute indexing\newline
				  {\tt whence == 1} then {\tt offset} relative to current pos\newline
				  {\tt whence == 2} then {\tt offset} relative to file end\\
\tt f.tell() 			& Return file {\tt f}'s current position (byte offset)\\
\tt f.truncate([size]) 		& Truncate {\tt f}'s {\tt size}. If {\tt size} is present, {\tt f} is truncated to (at most) that {\tt size}, 
				  otherwise {\tt f} is truncated at current position (which remains unchanged)\\
\hline
\tt f.write(str) 		& Write string {\tt str} to file {\tt f}\\
\tt f.writelines(list)  	& Write {\tt list} of strings to file {\tt f}. No {\tt EOL} are added\\
\hline
\end{longtable}

%-------------------------------------------------------------------------
%\newpage
\section{Utilitaire {\tt pydoc}}\label{python:pydoc}
%-------------------------------------------------------------------------
\noindent Cette annexe est un extrait du site officiel \python\ concernant {\tt pydoc} :
\href{http://docs.python.org/lib/module-pydoc.html}{\tt http\char`://docs.python.org /lib/module-pydoc.html}.
La figure \ref{fig:python:pydoc} ci-dessous illustre son utilisation.
\begin{fig}[Documentation en \python]\label{fig:python:pydoc}
\mbox{}\\\tt
\mbox{}\ \ \begin{minipage}{6.5cm}
\$ pydoc fibo\\
Help on module fibo:\\
\mbox{}\\
NAME\\
\mbox{}\ \ \ \ fibo
\mbox{}\\
FILE\\
\mbox{}\ \ \ \ /home/info/S1/cours/fonctions/fibo.py
\mbox{}\\
FUNCTIONS\\
\mbox{}\ \ \ \ fibonacci(n)\\
\mbox{}\ \ \ \ \ \ \ \ u = fibonacci(n) \\
\mbox{}\ \ \ \ \ \ \ \ est le nombre de Fibonacci \\
\mbox{}\ \ \ \ \ \ \ \ à l'ordre n si n:int >= 0 \\
\mbox{}\ \ \ \ \ \ \ \ >>> fibonacci(0)\\
\mbox{}\ \ \ \ \ \ \ \ 1\\
\mbox{}\ \ \ \ \ \ \ \ >>> fibonacci(2)\\
\mbox{}\ \ \ \ \ \ \ \ 2\\
\mbox{}\ \ \ \ \ \ \ \ >>> fibonacci(9)\\
\mbox{}\ \ \ \ \ \ \ \ 55
\end{minipage}
\end{fig}

\subsection*{{\tt pydoc} -- Documentation generator and online help system}
The pydoc module automatically generates documentation from Python modules. 
The documentation can be presented as pages of text on the console, 
served to a Web browser, or saved to HTML files.

The built-in function {\tt help()} invokes the online help system in the interactive interpreter, 
which uses {\tt pydoc} to generate its documentation as text on the console. 
The same text documentation can also be viewed from outside the \python\ interpreter 
by running {\tt pydoc} as a script at the operating system's command prompt. 
For example, running\\
{\tt pydoc sys}\\
at a shell prompt will display documentation on the {\tt sys} module, 
in a style similar to the manual pages shown by the Unix {\tt man} command. 
The argument to {\tt pydoc} can be the name of a function, module, or package, 
or a dotted reference to a class, method, or function within a module or module in a package. 
If the argument to {\tt pydoc} looks like a path (that is, it contains the path 
separator for your operating system, such as a slash in Unix), 
and refers to an existing {\sc Python} source file, 
then documentation is produced for that file.

Specifying a {\tt -w} flag before the argument will cause HTML documentation 
to be written out to a file in the current directory, instead of displaying 
text on the console.

Specifying a {\tt -k} flag before the argument will search the synopsis 
lines of all available modules for the keyword given as the argument, 
again in a manner similar to the Unix {\tt man} command. 
The synopsis line of a module is the first line of its documentation string.

You can also use {\tt pydoc} to start an HTTP server on the local machine 
that will serve documentation to visiting Web browsers. {\tt pydoc -p 1234} 
will start a HTTP server on port {\tt 1234}, allowing you to browse the 
documentation at {\tt http://localhost:1234/} in your preferred Web browser. 
{\tt pydoc -g} will start the server and additionally bring up a small 
{\tt Tkinter}-based graphical interface to help you search for documentation pages.

When {\tt pydoc} generates documentation, it uses the current environment 
and path to locate modules. Thus, invoking {\tt pydoc} spam documents 
precisely the version of the module you would get if you started the 
{\sc Python} interpreter and typed "import spam".

%-------------------------------------------------------------------------
\section{Transformation d'une récursivité terminale}\label{methode:recursivite}\index{{{\sc Gauss}}}
%-------------------------------------------------------------------------
Quel que soit le problème à résoudre, on a le choix entre l'écriture d'une fonction itérative et celle d'une
fonction récursive. Si le problème admet une décomposition récurrente naturelle, le programme récursif est
alors une simple adaptation de la décomposition choisie. C'est le cas des fonctions {\tt factorielle} et
{\tt fibonacci} par exemple. 
L'approche récursive présente cependant des inconvénients :
certains langages n'admettent pas la récursivité (comme le langage machine !)
et elle est souvent coûteuse en mémoire comme en temps d'exécution. 
On peut pallier ces inconvénients en transformant la fonction récursive 
en fonction itérative : c'est toujours possible.

Considérons une procédure {\tt f} à récursivité terminale écrite en pseudo-code :

\noindent\mbox{}\hspace*{1cm}\begin{py}{4cm}
\begin{verbatim}
def f(x):
    if cond: arret
    else:
        instructions
        f(g(x))
    return
\end{verbatim}
\end{py}
\hfill
\begin{py}{9cm}
{\tt x} représente ici la liste des arguments de la fonction,
{\tt cond} une condition portant sur {\tt x}, 
{\tt instructions} un bloc d'instructions qui constituent
le traitement de base de la fonction {\tt f}, 
{\tt g(x)} une transformation des arguments et {\tt arret}
l'instruction de terminaison (clause d'arrêt) de la récurrence.
\end{py}

\vspace*{2mm}

\noindent Elle est équivalente à la procédure itérative suivante :

\noindent\mbox{}\hspace*{1cm}\begin{py}{4cm}
\begin{verbatim}
def f(x):
    while not cond: 
        instructions
        x = g(x)
    arret
    return
\end{verbatim}
\end{py}

\vspace*{2mm}

\noindent Illustrons cette transformation à l'aide de la fonction qui calcule le {\tt pgcd} de 2 entiers.

\noindent\mbox{}\hspace*{1cm}\begin{py}{4cm}
\begin{verbatim}
def pgcd(a,b):
    if b == 0: return a
    else: 
        pass # ne fait rien
        return pgcd(b,a%b)

>>> pgcd(12,18)
6
\end{verbatim}
\end{py}
\hfill
\begin{py}{4cm}\tt
\begin{tabular}[t]{|l@{ $\rightarrow$ }l|}
\hline
x & a,b\\
cond & b == 0\\
arret & return a\\
instructions & {\rm pass}\\
x = g(x) & a,b = b,a\%b\\
\hline
\end{tabular}
\end{py}
\hfill
\begin{py}{4cm}
\begin{verbatim}
def pgcd(a,b):
    while not (b == 0):
        pass
        a,b = b,a%b
    return a

>>> pgcd(12,18)
6
\end{verbatim}
\end{py}

\vspace*{2mm}

La méthode précédente ne s'applique qu'à la récursivité terminale.

%-------------------------------------------------------------------------
\section{Méthode d'élimination de {\sc Gauss}}\label{gauss}\index{{{\sc Gauss}}}
%-------------------------------------------------------------------------
L'objectif est ici de 
résoudre dans $\mathbb{R}$ un système de $n$ équations linéaires
à $n$ inconnues, homogènes ou non homogènes, du type $A\cdot x = b$ :

\begin{equation}\label{eq1}
\left\{
\begin{array}{r@{\ +\ }r@{\ +\ }r@{\ +\ }r@{\ =\ }r}
a_{00}x_0     & a_{01}x_1     & \cdots & a_{0(n-1)}x_{(n-1)}     & b_0      \\
a_{10}x_0     & a_{11}x_1     & \cdots & a_{1(n-1)}x_{(n-1)}     & b_1      \\
\cdots        & \cdots        & \cdots & \cdots                  & \cdots   \\
a_{(n-1)0}x_0 & a_{(n-1)1}x_1 & \cdots & a_{(n-1)(n-1)}x_{(n-1)} & b_{(n-1)}
\end{array}
\right.
\end{equation}

\begin{fig}[Pont de Wheatstone]\label{fig:wheatstone}
$$\includegraphics[width=6cm]{../fig/wheatstone.pdf}$$
$$
\begin{array}{lcr}
r_1 & = & 10 \Omega \\
r_2 & = & 10 \Omega \\
r_3 & = &  5 \Omega \\
r_4 & = & 20 \Omega \\
r_5 & = & 10 \Omega \\
r_6 & = & 10 \Omega \\
E   & = & 12 V 
\end{array}
\hspace*{5mm}
\left|\begin{array}{l}
i_4 = i_1 + i_5\\
i_6 = i_1 + i_2\\
i_2 = i_3 + i_5\\
10 i_1 = 10 i_2 + 10 i_5\\
10 i_5 = 5 i_3 - 20 i_4\\
12 - 10 i_6 = 10 i_2 + 5 i_3
\end{array}\right.
$$
\end{fig}

De nombreux exemples traités dans les enseignements scientifiques
conduisent à la nécessité de résoudre un système de $n$ équations linéaires
à $n$ inconnues, homogènes ou non homogènes, du type $A\cdot x = b$. 
La figure \ref{fig:wheatstone}
propose à titre d'exemple le cas du pont de Wheatstone en électricité.
Les ponts ont été utilisés pour la mesure des résistances, inductances et
capacités jusqu'à ce que les progrès en électronique les rendent obsolètes en
métrologie. Toutefois la structure en pont reste encore utilisée dans de 
nombreux montages.

La première méthode généralement utilisée pour trouver la solution 
d'un système d'équa\-tions linéaires tel que le système (\ref{eq1}) 
est celle qui consiste à éliminer les inconnues 
($x_i$) en combinant les équations.
Pour illustrer cette méthode, nous commencerons par étudier un exemple
simple pouvant s'effectuer {\em à la main}, 
puis nous passerons au cas général pour
présenter la méthode d'élimination de {\sc Gauss}.

%-------------------------------------------------------------------------
\subsection*{Etude d'un cas particulier}
\label{casparticulier}
%-------------------------------------------------------------------------
Considérons le système suivant :
$$\left\{
\begin{array}{rcrcrcr}
 x_0 & + &  x_1 & + &   x_2 & = &  1 \\
2x_0 & + & 4x_1 & + &  8x_2 & = & 10 \\
3x_0 & + & 9x_1 & + & 27x_2 & = & 33
\end{array}
\right.$$

Pour résoudre un tel système, l'idée de base est de triangulariser 
le système de telle manière qu'il soit possible de remonter les
solutions par substitutions successives.

La première étape consiste à éliminer le terme en $x_0$ des 
$2^{\grave eme}$ et $3^{\grave eme}$ équations.
Cherchons tout d'abord à éliminer le terme en $x_0$ de la $2^{\grave eme}$
équation. Pour cela nous multiplions la $1^{\grave ere}$ équation par le 
coefficient de $x_0$ de la $2^{\grave eme}$ équation ($a_{10} = 2$). 
On obtient le nouveau système :
$$\left\{
\begin{array}{rcrcrcr}
2x_0 & + & 2x_1 & + &  2x_2 & = &  2 \\
2x_0 & + & 4x_1 & + &  8x_2 & = & 10 \\
3x_0 & + & 9x_1 & + & 27x_2 & = & 33
\end{array}
\right.$$
On soustrait alors la première équation de la deuxième équation, 
ce qui conduit au système :
$$\left\{
\begin{array}{rcrcrcr}
2x_0 & + & 2x_1 & + &  2x_2 & = &  2 \\
     &   & 2x_1 & + &  6x_2 & = &  8 \\
3x_0 & + & 9x_1 & + & 27x_2 & = & 33
\end{array}
\right.$$
On recommence l'opération pour éliminer le terme en $x_0$ de la $3^{\grave eme}$
équation. Pour cela, on ramène à $1$ le coefficient de $x_0$ dans
la première équation en divisant cette équation par 2 ($a_{00} = 2$),
puis nous multiplions la $1^{\grave ere}$ équation par le 
coefficient de $x_0$ de la $3^{\grave eme}$ équation ($a_{20} = 3$). 
$$\left\{
\begin{array}{rcrcrcr}
3x_0 & + & 3x_1 & + &  3x_2 & = &  3 \\
     &   & 2x_1 & + &  6x_2 & = &  8 \\
3x_0 & + & 9x_1 & + & 27x_2 & = & 33
\end{array}
\right.$$
On soustrait ensuite la $1^{\grave ere}$ équation de la $3^{\grave eme}$ équation :
$$\left\{
\begin{array}{rcrcrcr}
3x_0 & + & 3x_1 & + &  3x_2 & = &  3 \\
     &   & 2x_1 & + &  6x_2 & = &  8 \\
     &   & 6x_1 & + & 24x_2 & = & 30
\end{array}
\right.$$
On obtient un nouveau système linéaire dans lequel seule la première équation contient
un terme en $x_0$.
L'équation utilisée (ici la $1^{\grave ere}$ équation) pour éliminer une inconnue 
dans les équations qui suivent (ici les $2^{\grave eme}$ et $3^{\grave eme}$ équations)
est appelée l'équation-pivot. Dans l'équation-pivot choisie, le coefficient de 
l'inconnue qui est éliminée dans les autres équations est appelé le pivot de
l'équation (ici $a_{00}$).

La deuxième étape consiste à éliminer le terme en $x_1$ de la troisième équation
en utilisant la deuxième équation comme équation-pivot. On ramène à $1$ le coefficient 
de $x_1$ dans la $2^{\grave eme}$ équation en divisant l'équation par 2 ($a_{11} = 2$),
puis on la multiplie par 6 ($a_{21} = 6$) pour que les $2^{\grave eme}$ et 
$3^{\grave eme}$ équations aient le même terme en $x_1$. Tout revient à
multiplier la $2^{\grave eme}$ équation par 3 ($a_{21}/a_{11} = 6/2 = 3$) :
$$\left\{
\begin{array}{rcrcrcr}
3x_0 & + & 3x_1 & + &  3x_2 & = &  3 \\
     &   & 6x_1 & + & 18x_2 & = & 24 \\
     &   & 6x_1 & + & 24x_2 & = & 30
\end{array}
\right.$$
Il reste à soustraire la $2^{\grave eme}$ équation de la $3^{\grave eme}$
pour éliminer le terme en $x_1$ de la $3^{\grave eme}$ équation :
$$\left\{
\begin{array}{rcrcrcr}
3x_0 & + & 3x_1 & + &  3x_2 & = &  3 \\
     &   & 6x_1 & + & 18x_2 & = & 24 \\
     &   &      &   &  6x_2 & = &  6
\end{array}
\right.$$
On obtient ainsi un système triangulaire d'équations linéaires 
dont on peut calculer
directement la valeur de $x_2$ par la $3^{\grave eme}$ équation : $6x_2 =  6 \Rightarrow
x_2 = 1$. On porte cette valeur de $x_2$ dans la deuxième équation, ce qui nous permet de
calculer $x_1$ : $6x_1 + 18\cdot 1 = 24 \Rightarrow x_1 = 1$. En reportant les valeurs de
$x_2$ et $x_1$ dans la première équation, on en déduit la valeur de $x_0$ :
$3x_0 + 3\cdot 1 +  3\cdot 1 =  3 \Rightarrow x_0 = -1$. 
On vérifie simplement que
les valeurs obtenues sont solutions du système initial :
$$\left\{
\begin{array}{rcrcrcr}
 x_0 & + &  x_1 & + &   x_2 & = &  1 \\
2x_0 & + & 4x_1 & + &  8x_2 & = & 10 \\
3x_0 & + & 9x_1 & + & 27x_2 & = & 33
\end{array}
\right.
\hspace*{2cm}
\left(
\begin{array}{rrr}
1 & 1 &  1 \\
2 & 4 &  8 \\
3 & 9 & 27 
\end{array}
\right)
\cdot
\left(
\begin{array}{r}
-1 \\ 1 \\ 1
\end{array}
\right)
=
\left(
\begin{array}{r}
1 \\ 10 \\ 33
\end{array}
\right)$$

%-------------------------------------------------------------------------
\subsection*{Etude du cas général}
\label{casgeneral}
%-------------------------------------------------------------------------
De manière générale, la méthode précédente consiste à réduire le système de $n$ 
équations à $n$ inconnues à un système triangulaire équivalent qui peut 
être ensuite résolu facilement par substitutions. En quelque sorte le système 
(\ref{eq1}) doit être transformé en un système équivalent du type :
\begin{equation}\label{eq2}
\left\{
\begin{array}{rcrcrcrcr@{\ =\ }r}
a_{00}x_0 &+& a_{01}x_1       &+& a_{02}x_2       &+& \cdots &+& a_{0(n-1)}x_{(n-1)}       & b_0\\
          & & a^{(1)}_{11}x_1 &+& a^{(1)}_{12}x_2 &+& \cdots &+& a^{(1)}_{1(n-1)}x_{(n-1)} & b^{(1)}_1\\
          & &                 &+& a^{(2)}_{22}x_2 &+& \cdots &+& a^{(2)}_{2(n-1)}x_{(n-1)} & b^{(2)}_2\\
          & &                 & &                 & & \cdots &+& \cdots           & \cdots\\
          & &                 & &                 & &        & & a^{(n-2)}_{(n-1)(n-1)}x_{(n-1)}   & b^{(n-2)}_{(n-1)}
\end{array}
\right.
\end{equation}
où l'indice supérieur désigne le nombre d'étapes à la suite desquelles est obtenu le 
coefficient considéré.

L'équation de rang 0 du système (\ref{eq1}) est d'abord divisée par le coefficient 
$a_{00}$ de $x_0$ (supposé non nul). On obtient :
\begin{equation}\label{eq3}
x_0 + \frac{a_{01}}{a_{00}}x_1 + \frac{a_{02}}{a_{00}}x_2 + \cdots + \frac{a_{0(n-1)}}{a_{00}}x_{(n-1)} = \frac{b_0}{a_{00}}
\end{equation}
Cette équation (\ref{eq3}) est alors multiplié par $a_{10}$, coefficient de $x_0$ dans 
la deuxième équation du système (\ref{eq1}). Le résultat est ensuite soustrait de la 
deuxième équation du système (\ref{eq1}), ce qui élimine $x_0$ dans la deuxième équation.
D'une manière générale on multiplie la relation (\ref{eq3}) par $a_{i0}$, coefficient
de $x_0$ dans l'équation de rang $i$ du système (\ref{eq1}) et on retranche le résultat
obtenu de cette même $i^{\grave eme}$ équation. A la fin $x_0$ est éliminé de toutes les équations, excepté de la première, et on obtient le système ainsi transformé :
\begin{equation}\label{eq4}
\left\{
\begin{array}{rcrcrcrcr@{\ =\ }r}
a_{00}x_0 &+& a_{01}x_1       &+& a_{02}x_2       &+& \cdots &+& a_{0(n-1)}x_{(n-1)}       & b_0\\
          & & a^{(1)}_{11}x_1 &+& a^{(1)}_{12}x_2 &+& \cdots &+& a^{(1)}_{1(n-1)}x_{(n-1)} & b^{(1)}_1\\
          & & a^{(1)}_{21}x_1 &+& a^{(1)}_{22}x_2 &+& \cdots &+& a^{(1)}_{2(n-1)}x_{(n-1)} & b^{(1)}_2\\
          & & a^{(1)}_{31}x_1 &+& a^{(1)}_{32}x_2 &+& \cdots &+& a^{(1)}_{3(n-1)}x_{(n-1)} & b^{(1)}_3\\
          & & \cdots          &+& \cdots          &+& \cdots &+& \cdots                    & \cdots\\
          & & a^{(1)}_{(n-1)1}x_1 &+& a^{(1)}_{(n-1)2}x_2 &+& \cdots &+& a^{(1)}_{(n-1)(n-1)}x_{(n-1)}   & b^{(1)}_{(n-1)}
\end{array}
\right.
\end{equation}
L'équation de rang 1 dans le nouveau système (\ref{eq4}) devient alors l'équation-pivot
et $a^{(1)}_{11}$ le pivot de l'équation. De la même façon on élimine $x_1$ des
équations du rang $2$ au rang $n-1$ dans le système (\ref{eq4}), et on obtient :
\begin{equation}\label{eq5}
\left\{
\begin{array}{rcrcrcrcr@{\ =\ }r}
a_{00}x_0 &+& a_{01}x_1       &+& a_{02}x_2       &+& \cdots &+& a_{0(n-1)}x_{(n-1)}       & b_0\\
          & & a^{(1)}_{11}x_1 &+& a^{(1)}_{12}x_2 &+& \cdots &+& a^{(1)}_{1(n-1)}x_{(n-1)} & b^{(1)}_1\\
          & &                 & & a^{(2)}_{22}x_2 &+& \cdots &+& a^{(2)}_{2(n-1)}x_{(n-1)} & b^{(2)}_2\\
          & &                 & & a^{(2)}_{32}x_2 &+& \cdots &+& a^{(2)}_{3(n-1)}x_{(n-1)} & b^{(2)}_3\\
          & &                 & & \cdots          &+& \cdots &+& \cdots                    & \cdots\\
          & &                 & & a^{(2)}_{(n-1)2}x_2 &+& \cdots &+& a^{(2)}_{(n-1)(n-1)}x_{(n-1)}   & b^{(2)}_{(n-1)}
\end{array}
\right.
\end{equation}
L'équation de rang 2 dans le nouveau système (\ref{eq5}) fait office à son tour d'équation
pivot, et ainsi de suite jusqu'à obtenir le système triangulaire (\ref{eq2}).
Une fois obtenu ce système triangulaire, on calcule directement
la valeur de $x_{(n-1)}$ par la dernière relation du système triangulaire. 
En portant cette valeur dans la relation précédente, on calculera
$x_{(n-2)}$, et ainsi de suite en remontant le système triangulaire (\ref{eq2}).
A chaque étape $k$, on a donc les relations suivantes :
\begin{enumerate}
\item {Triangularisation}
	$$\left\{
	\begin{array}{lcl}
	a_{ij}^{(k)} & = & \displaystyle a_{ij}^{(k-1)} - \frac{a_{ip}^{(k-1)}}{a_{pp}^{(k-1)}}\cdot
	a_{pj}^{(k-1)} \\[5mm]
	b_i^{(k)}    & = & \displaystyle b_i^{(k-1)} - \frac{a_{ip}^{(k-1)}}{a_{pp}^{(k-1)}}\cdot
	b_p^{(k-1)}
	\end{array}
	\right.\mbox{\footnotesize\ avec\ }
	\left\{
	\begin{array}{l}
	k\ :\ \mbox{\footnotesize étape}\\
	p\ : \ \mbox{\footnotesize rang du pivot}\\[5mm]
	p < i \leq (n-1) \\[2mm]
	p \leq j \leq (n-1)
	\end{array}
	\right.$$
\item {Remontée par substitutions} 
	$$\left\{
	\begin{array}{lcl}
	x_{(n-1)} & = & \displaystyle\frac{b_{(n-1)}}{a_{(n-1)(n-1)}}\\[5mm]
	x_i       & = & \displaystyle\frac{\displaystyle b_{i} - 
	\sum_{j=i+1}^{n-1} a_{ij}x_j}{a_{ii}} 
	\end{array}
	\right.
	\mbox{\ avec\ } 0 \leq i < (n-1)$$
\end{enumerate}

Jusqu'à présent, on a admis que le pivot au cours du processus de triangularisation 
était non nul ($a_{pp} \neq 0$). Si ce n'est pas le cas, on doit permuter 
l'équation-pivot avec une autre ligne dans laquelle le pivot est différent de 0.
Il se peut également que le pivot, sans être nul, soit très petit et l'on a 
intérêt là-aussi à interchanger les lignes comme pour le cas d'un pivot nul.
En fait, pour augmenter la précision de la solution obtenue, on a toujours 
intérêt à utiliser la ligne qui a le plus grand pivot.

Cette méthode est connue sous le nom de méthode d'élimination 
de {\sc Gauss} (également connue sous
le nom de méthode de triangularisation de {\sc Gauss} ou méthode du pivot 
de {\sc Gauss}). Elle fut nommée ainsi en l'honneur du mathématicien allemand 
{\sc Johann Carl Friedrich Gauss} (1777--1855), mais elle est connue des Chinois 
depuis au moins le $1^{er}$ siècle de notre ère. Elle est référencée dans le livre 
chinois « Jiuzhang suanshu~» où elle est attribuée à {\sc Chang Ts'ang} chancelier de 
l'empereur de Chine au $2^{\grave eme}$ siècle avant notre ère. 


%-------------------------------------------------------------------------
\subsection*{Jeu de tests}
%-------------------------------------------------------------------------
L'algorithme de résolution de tels systèmes linéaires pourra être testé
à l'aide des systèmes suivants :
$$\begin{array}{|l|c|c|c|}
\hline
\mbox{\bf Test} & \multicolumn{2}{|c|}{\mbox{{\bf Système} $A\cdot x = b$}} & \bf Solution\\
\cline{2-3}
                & A & b & \bf exacte \\
\hline
\hline
1 
& 
\left(\begin{array}{r}
4
\end{array}\right) 
&
\left(\begin{array}{r}
1
\end{array}\right) 
&
\displaystyle
\left(\begin{array}{r}
1/4
\end{array}\right)\\
\hline
2 
& 
\left(\begin{array}{rr}
1 & 1 \\
1 & -1
\end{array}\right) 
&
\left(\begin{array}{r}
1 \\ 0
\end{array}\right)
&
\displaystyle
\left(\begin{array}{r}
1/2 \\ 1/2
\end{array}\right)
\\
\hline
3 
& 
\left(\begin{array}{rrr}
2 & -1 & 2 \\
1 & 10 & -3 \\
-1 & 2 & 1
\end{array}\right) 
&
\left(\begin{array}{r}
2 \\ 5 \\ -3
\end{array}\right)
&
\left(\begin{array}{r}
2 \\ 0 \\ -1
\end{array}\right)
\\
\hline
\end{array}$$


$$\begin{array}{|l|c|c|c|}
\hline
\mbox{\bf Test} & \multicolumn{2}{|c|}{\mbox{{\bf Système} $A\cdot x = b$}} & \bf Solution\\
\cline{2-3}
                & A & b & \bf exacte \\
\hline
4 &
\left(\begin{array}{rrrr}
10 & 7 & 8 & 7 \\
7 & 5 & 6 & 5 \\
8 & 6 & 10 & 9 \\
7 & 5 & 9 & 10
\end{array}\right) 
&
\left(\begin{array}{r}
32 \\ 23 \\ 33 \\ 31
\end{array}\right) 
&
\left(\begin{array}{r}
1 \\ 1 \\ 1 \\ 1
\end{array}\right) 
\\
\hline
5 & 
\left(\begin{array}{rrrr}
10 & 7 & 8.1 & 7.2 \\
7.08 & 5.04 & 6 & 5 \\
8 & 5.98 & 9.89 & 9 \\
6.99 & 4.99 & 9 & 9.98
\end{array}\right) 
&
\left(\begin{array}{r}
32 \\ 23 \\ 33 \\ 31
\end{array}\right) 
&
\mbox{---} \\
\hline
6 &
\left(\begin{array}{rrrr}
10 & 7 & 8 & 7 \\
7 & 5 & 6 & 5 \\
8 & 6 & 10 & 9 \\
7 & 5 & 9 & 10
\end{array}\right) 
&
\left(\begin{array}{r}
32.01 \\ 22.99 \\ 33.01 \\ 30.99
\end{array}\right) 
&
\mbox{---} \\
\hline
\end{array}$$

Les tests 5 et 6 sont des variations du test 4 : $A_5 = A_4 + \Delta A$
et $b_6 = b_4 + \Delta b$. Ces 2 tests sont effectués pour évaluer 
les conséquences sur la solution $x$ d'une perturbation $\Delta A$ de $A_4$
et d'une perturbation $\Delta b$ de $b_4$.
$$\Delta A = \left(\begin{array}{rrrr}
0 & 0 & 0.1 & 0.2\\
0.08 & 0.04 & 0 & 0\\
0 & -0.02 & -0.11 & 0\\
-0.01 & -0.01 & 0 & -0.02
\end{array}
\right)$$
$$\Delta b = \left(\begin{array}{r}
0.01 \\ - 0.01 \\ 0.01 \\ -0.01
\end{array}\right)$$
$$\begin{array}{|l|c|c|}
\hline
\mbox{\bf Test} & \multicolumn{2}{|c|}{\mbox{{\bf Système} $A\cdot x = b$}}\\
\cline{2-3}
                & A & b  \\
\hline
\hline
7 &
\left(\begin{array}{rrrrrr}
1 & 0 & 0 & - & 1 & 0\\
1 & 1 & 0 & 0 & 0 & -1\\
0 & 1 & -1 & 0 & -1 & 0\\
10 & -10 & 0 & 0 & -10 & 0\\
0 & 0 & 5 & -20 & -10 & 0\\
0 & 10 & 5 & 0 & 0 & 10
\end{array}\right) 
&
\left(\begin{array}{r}
0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 12
\end{array}\right)\\
\hline
8 &
\left(\begin{array}{rrrrrrrr}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
1 & 2\pi & 4\pi^2 & 8\pi^3 & 16\pi^4 & 32\pi^5 & 64\pi^6 & 128\pi^7\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 4\pi & 12\pi^2 & 32\pi^3 & 80\pi^4 & 192\pi^5 & 448\pi^6\\
1 & \pi/2 & \pi^2/4 & \pi^3/8 & \pi^4/16 & \pi^5/32 & \pi^6/64 & \pi^7/128\\
0 & \pi/2 & \pi & 3\pi^2/4 & \pi^3/2 & 5\pi^4/16 & 3\pi^5/16 & 7\pi^6/64\\
1 & \pi & \pi^2 & \pi^3 & \pi^4 & \pi^5 & \pi^6 & \pi^7\\
0 & \pi & 2\pi & 3\pi^2 & 4\pi^3 & 5\pi^4 & 6\pi^5 & 7\pi^6
\end{array}\right) 
&
\left(\begin{array}{r}
4 \\ 4 \\ 0 \\ 0 \\ 2 \\ -2 \\ 1 \\ 0
\end{array}\right)\\
\hline
\end{array}$$


Le test 7 correspond à l'exemple du pont de Wheatstone 
(figure \ref{fig:wheatstone}). Le test 8 correspond
à la détermination de la forme d'une came rotative qui doit
mettre en mouvement un axe suivant une loi horaire donnée.
